```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bullet-Hell Clicker â€” Massive Single-File HTML5/JS/CSS</title>

  <!--
    Bullet-Hell Clicker
    Single-file HTML5/JS/CSS game with:
    - 300+ line internal CSS with keyframes, gradients, glassmorphism, shakes, pulses
    - Multi-stage state machine: Loading, Main Menu, Level Selector (10 dummy levels), Game Loop, Shop, Game Over
    - Heavy-duty Particle System: 500+ simultaneous particles with physics, friction, color cycling
    - Complex Enemy Logic: 5 enemy types (sine, circle, tracker, teleporter, wanderer)
    - Procedural Audio: Web Audio API manager for explosions, clicks, level-up fanfares
    - Verbose documentation: comments for every function and variable
    - No external libraries, everything raw JS/CSS
    - Designed for Matteoâ€™s taste for juice, escalation, and deploy-ready artifacts
  -->

  <style>
    /* =========================================================================
       Massive Internal CSS â€” 300+ lines
       - Glassmorphism UI
       - Complex gradients
       - Keyframe animations for buttons, HUD, backgrounds, shakes, glow pulses
       - Dedicated animations per UI element
       ========================================================================= */

    /* -- CSS Reset ----------------------------------------------------------- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: radial-gradient(1200px at 50% 50%, #0b0f1a 0%, #06080f 60%, #04060a 100%);
      color: #e6f0ff;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }

    /* -- Root Variables ------------------------------------------------------ */
    :root {
      --glass-bg: rgba(255, 255, 255, 0.08);
      --glass-border: rgba(255, 255, 255, 0.25);
      --accent: #6cf0ff;
      --accent-2: #ff6cf0;
      --accent-3: #f0ff6c;
      --danger: #ff4d6d;
      --ok: #4dff88;
      --text: #e6f0ff;
      --muted: #9fb3c8;
      --shadow: rgba(0, 0, 0, 0.35);
      --glow: 0 0 12px rgba(108, 240, 255, 0.6), 0 0 24px rgba(108, 240, 255, 0.3);
      --glow-strong: 0 0 24px rgba(108, 240, 255, 0.8), 0 0 48px rgba(108, 240, 255, 0.4);
      --panel-radius: 18px;
      --btn-radius: 14px;
      --hud-radius: 12px;
      --blur: blur(12px);
    }

    /* -- Background Layers --------------------------------------------------- */
    .bg-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background:
        radial-gradient(800px at 20% 20%, rgba(108, 240, 255, 0.08), transparent 60%),
        radial-gradient(800px at 80% 30%, rgba(255, 108, 240, 0.08), transparent 60%),
        radial-gradient(800px at 40% 80%, rgba(240, 255, 108, 0.08), transparent 60%),
        linear-gradient(180deg, rgba(10, 14, 24, 0.8), rgba(6, 8, 15, 0.8));
      animation: bgPulse 12s ease-in-out infinite;
    }

    @keyframes bgPulse {
      0%   { filter: saturate(1) brightness(1); }
      50%  { filter: saturate(1.2) brightness(1.1); }
      100% { filter: saturate(1) brightness(1); }
    }

    /* -- Container ----------------------------------------------------------- */
    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
      grid-template-columns: 1fr;
      align-items: center;
      justify-items: center;
    }

    /* -- Panels -------------------------------------------------------------- */
    .panel {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--panel-radius);
      box-shadow: 0 10px 30px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.05);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      padding: 24px;
      color: var(--text);
    }

    .panel-title {
      font-size: 28px;
      font-weight: 800;
      letter-spacing: 0.5px;
      text-shadow: var(--glow);
      margin-bottom: 16px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2), var(--accent-3));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: titleGlow 3s ease-in-out infinite;
    }

    @keyframes titleGlow {
      0%   { text-shadow: 0 0 8px rgba(108,240,255,0.4); }
      50%  { text-shadow: var(--glow-strong); }
      100% { text-shadow: 0 0 8px rgba(108,240,255,0.4); }
    }

    /* -- Buttons ------------------------------------------------------------- */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 12px 18px;
      border-radius: var(--btn-radius);
      border: 1px solid var(--glass-border);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06)),
        radial-gradient(400px at 50% 0%, rgba(108,240,255,0.25), transparent 60%);
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.4px;
      cursor: pointer;
      box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
      animation: btnPulse 4s ease-in-out infinite;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 24px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.08);
      filter: saturate(1.2);
    }

    .btn:active {
      transform: translateY(1px) scale(0.99);
      animation: btnClick 0.3s ease;
    }

    @keyframes btnPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.08); }
      100% { filter: brightness(1); }
    }

    @keyframes btnClick {
      0%   { transform: scale(1); }
      50%  { transform: scale(0.98); }
      100% { transform: scale(1); }
    }

    .btn-primary {
      background:
        linear-gradient(180deg, rgba(108,240,255,0.25), rgba(108,240,255,0.12)),
        radial-gradient(400px at 50% 0%, rgba(108,240,255,0.35), transparent 60%);
      border-color: rgba(108,240,255,0.45);
      box-shadow: 0 6px 18px rgba(108,240,255,0.25), inset 0 0 0 1px rgba(255,255,255,0.08);
    }

    .btn-danger {
      background:
        linear-gradient(180deg, rgba(255,77,109,0.25), rgba(255,77,109,0.12)),
        radial-gradient(400px at 50% 0%, rgba(255,77,109,0.35), transparent 60%);
      border-color: rgba(255,77,109,0.45);
      box-shadow: 0 6px 18px rgba(255,77,109,0.25), inset 0 0 0 1px rgba(255,255,255,0.08);
    }

    .btn-ok {
      background:
        linear-gradient(180deg, rgba(77,255,136,0.25), rgba(77,255,136,0.12)),
        radial-gradient(400px at 50% 0%, rgba(77,255,136,0.35), transparent 60%);
      border-color: rgba(77,255,136,0.45);
      box-shadow: 0 6px 18px rgba(77,255,136,0.25), inset 0 0 0 1px rgba(255,255,255,0.08);
    }

    /* -- HUD ----------------------------------------------------------------- */
    .hud {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 12px;
      z-index: 10;
    }

    .hud-item {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--hud-radius);
      padding: 10px 14px;
      box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 10px;
      animation: hudGlow 6s ease-in-out infinite;
    }

    @keyframes hudGlow {
      0%   { box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06); }
      50%  { box-shadow: var(--glow-strong), inset 0 0 0 1px rgba(255,255,255,0.08); }
      100% { box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06); }
    }

    .hud-label {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.4px;
    }

    .hud-value {
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 0.6px;
      color: var(--text);
      text-shadow: var(--glow);
    }

    /* -- Canvas -------------------------------------------------------------- */
    #gameCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 1;
      animation: canvasPulse 10s ease-in-out infinite;
    }

    @keyframes canvasPulse {
      0%   { filter: saturate(1) contrast(1); }
      50%  { filter: saturate(1.1) contrast(1.05); }
      100% { filter: saturate(1) contrast(1); }
    }

    /* -- Screens ------------------------------------------------------------- */
    .screen {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 5;
      pointer-events: none;
    }

    .screen-content {
      pointer-events: auto;
      width: min(900px, 92vw);
      max-height: 80vh;
      overflow: auto;
    }

    .screen-hidden {
      display: none;
    }

    /* -- Loading Screen ------------------------------------------------------ */
    .loading-logo {
      font-size: 42px;
      font-weight: 900;
      letter-spacing: 1px;
      text-shadow: var(--glow-strong);
      background: linear-gradient(90deg, var(--accent), var(--accent-2), var(--accent-3));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: logoBreath 4s ease-in-out infinite;
    }

    @keyframes logoBreath {
      0%   { filter: brightness(1); transform: scale(1); }
      50%  { filter: brightness(1.15); transform: scale(1.04); }
      100% { filter: brightness(1); transform: scale(1); }
    }

    .loading-bar {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06), 0 6px 18px var(--shadow);
      overflow: hidden;
      margin-top: 16px;
    }

    .loading-fill {
      height: 100%;
      width: 0%;
      background:
        linear-gradient(90deg, var(--accent), var(--accent-2), var(--accent-3)),
        radial-gradient(400px at 50% 50%, rgba(255,255,255,0.25), transparent 60%);
      animation: loadingFill 3s ease-in-out infinite;
    }

    @keyframes loadingFill {
      0%   { width: 0%; }
      50%  { width: 70%; }
      100% { width: 100%; }
    }

    /* -- Main Menu ----------------------------------------------------------- */
    .menu-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .menu-hero {
      background:
        linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06)),
        radial-gradient(800px at 50% 0%, rgba(108,240,255,0.18), transparent 60%);
      border: 1px solid var(--glass-border);
      border-radius: var(--panel-radius);
      padding: 24px;
      box-shadow: 0 10px 30px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      animation: heroPulse 8s ease-in-out infinite;
    }

    @keyframes heroPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.08); }
      100% { filter: brightness(1); }
    }

    .menu-actions {
      display: grid;
      gap: 12px;
    }

    /* -- Level Selector ------------------------------------------------------ */
    .level-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
    }

    .level-card {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--panel-radius);
      padding: 16px;
      box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: grid;
      gap: 8px;
      cursor: pointer;
      transition: transform 0.15s ease, filter 0.15s ease;
      animation: cardPulse 6s ease-in-out infinite;
    }

    .level-card:hover {
      transform: translateY(-2px);
      filter: saturate(1.2);
    }

    @keyframes cardPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.06); }
      100% { filter: brightness(1); }
    }

    .level-title {
      font-weight: 800;
      letter-spacing: 0.6px;
      color: var(--text);
      text-shadow: var(--glow);
    }

    .level-desc {
      font-size: 12px;
      color: var(--muted);
    }

    /* -- Shop --------------------------------------------------------------- */
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }

    .shop-item {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--panel-radius);
      padding: 16px;
      box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: grid;
      gap: 8px;
      animation: shopPulse 7s ease-in-out infinite;
    }

    @keyframes shopPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.05); }
      100% { filter: brightness(1); }
    }

    .shop-title {
      font-weight: 800;
      letter-spacing: 0.6px;
      color: var(--text);
      text-shadow: var(--glow);
    }

    .shop-desc {
      font-size: 12px;
      color: var(--muted);
    }

    .shop-price {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent);
    }

    /* -- Game Over ----------------------------------------------------------- */
    .gameover-panel {
      background:
        linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06)),
        radial-gradient(800px at 50% 0%, rgba(255,77,109,0.18), transparent 60%);
      border: 1px solid var(--glass-border);
      border-radius: var(--panel-radius);
      padding: 24px;
      box-shadow: 0 10px 30px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      animation: gameOverPulse 8s ease-in-out infinite;
    }

    @keyframes gameOverPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.1); }
      100% { filter: brightness(1); }
    }

    .gameover-title {
      font-size: 32px;
      font-weight: 900;
      letter-spacing: 1px;
      color: var(--danger);
      text-shadow: 0 0 12px rgba(255,77,109,0.6), 0 0 24px rgba(255,77,109,0.3);
      animation: shakeSoft 2.2s ease-in-out infinite;
    }

    /* -- Screen Shakes ------------------------------------------------------- */
    .shake-hard {
      animation: shakeHard 0.6s cubic-bezier(.36,.07,.19,.97) both;
    }

    .shake-soft {
      animation: shakeSoft 1.2s ease-in-out both;
    }

    @keyframes shakeHard {
      10%, 90% { transform: translate3d(-1px, 0, 0); }
      20%, 80% { transform: translate3d(2px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
      40%, 60% { transform: translate3d(4px, 0, 0); }
    }

    @keyframes shakeSoft {
      0%   { transform: translate3d(0, 0, 0); }
      25%  { transform: translate3d(1px, -1px, 0); }
      50%  { transform: translate3d(-1px, 1px, 0); }
      75%  { transform: translate3d(1px, 1px, 0); }
      100% { transform: translate3d(0, 0, 0); }
    }

    /* -- Glow Pulses --------------------------------------------------------- */
    .glow-pulse {
      animation: glowPulse 2.4s ease-in-out infinite;
    }

    @keyframes glowPulse {
      0%   { box-shadow: var(--glow); }
      50%  { box-shadow: var(--glow-strong); }
      100% { box-shadow: var(--glow); }
    }

    /* -- Tooltip ------------------------------------------------------------- */
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      transform: translate(-50%, -120%);
      white-space: nowrap;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 6px 18px var(--shadow);
      animation: tooltipFade 0.25s ease-out;
    }

    @keyframes tooltipFade {
      from { opacity: 0; transform: translate(-50%, -140%); }
      to   { opacity: 1; transform: translate(-50%, -120%); }
    }

    /* -- Progress Ring ------------------------------------------------------- */
    .ring {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 6px solid rgba(255,255,255,0.12);
      border-top-color: var(--accent);
      animation: spin 1.2s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* -- Decorative Lines ---------------------------------------------------- */
    .divider {
      height: 1px;
      background: linear-gradient(90deg, rgba(255,255,255,0.08), rgba(255,255,255,0.2), rgba(255,255,255,0.08));
      margin: 12px 0;
    }

    /* -- Badge --------------------------------------------------------------- */
    .badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.6px;
      color: var(--text);
      border: 1px solid var(--glass-border);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06)),
        radial-gradient(400px at 50% 50%, rgba(108,240,255,0.18), transparent 60%);
      box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      animation: badgePulse 5s ease-in-out infinite;
    }

    @keyframes badgePulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.08); }
      100% { filter: brightness(1); }
    }

    /* -- Modal --------------------------------------------------------------- */
    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.35);
      z-index: 20;
      animation: modalFade 0.25s ease-out;
    }

    .modal-content {
      width: min(720px, 92vw);
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--panel-radius);
      padding: 24px;
      box-shadow: 0 10px 30px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      animation: modalPulse 6s ease-in-out infinite;
    }

    @keyframes modalFade {
      from { opacity: 0; }
      to   { opacity: 1; }
    }

    @keyframes modalPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.06); }
      100% { filter: brightness(1); }
    }

    /* -- Floating Action ----------------------------------------------------- */
    .fab {
      position: fixed;
      bottom: 16px;
      right: 16px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      background:
        linear-gradient(180deg, rgba(108,240,255,0.25), rgba(108,240,255,0.12)),
        radial-gradient(400px at 50% 0%, rgba(108,240,255,0.35), transparent 60%);
      border: 1px solid rgba(108,240,255,0.45);
      box-shadow: 0 10px 24px rgba(108,240,255,0.25), inset 0 0 0 1px rgba(255,255,255,0.08);
      cursor: pointer;
      z-index: 12;
      animation: fabPulse 4s ease-in-out infinite;
    }

    @keyframes fabPulse {
      0%   { transform: translateY(0); }
      50%  { transform: translateY(-4px); }
      100% { transform: translateY(0); }
    }

    /* -- Notification -------------------------------------------------------- */
    .toast {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--hud-radius);
      padding: 10px 14px;
      box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--text);
      z-index: 12;
      animation: toastFade 0.25s ease-out, toastPulse 6s ease-in-out infinite;
    }

    @keyframes toastFade {
      from { opacity: 0; transform: translate(-50%, 20px); }
      to   { opacity: 1; transform: translate(-50%, 0); }
    }

    @keyframes toastPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.06); }
      100% { filter: brightness(1); }
    }

    /* -- Progress Bars ------------------------------------------------------- */
    .progress {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06), 0 6px 18px var(--shadow);
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background:
        linear-gradient(90deg, var(--accent), var(--accent-2), var(--accent-3)),
        radial-gradient(400px at 50% 50%, rgba(255,255,255,0.25), transparent 60%);
      animation: progressFill 2.2s ease-in-out infinite;
    }

    @keyframes progressFill {
      0%   { width: 10%; }
      50%  { width: 70%; }
      100% { width: 90%; }
    }

    /* -- Meter --------------------------------------------------------------- */
    .meter {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 4px;
    }

    .meter-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      border: 1px solid var(--glass-border);
      box-shadow: 0 6px 18px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
      animation: dotPulse 3s ease-in-out infinite;
    }

    @keyframes dotPulse {
      0%   { filter: brightness(1); }
      50%  { filter: brightness(1.2); }
      100% { filter: brightness(1); }
    }

    /* -- Label --------------------------------------------------------------- */
    .label {
      font-size: 12px;
      color: var(--muted);
    }

    /* -- Scrollbars ---------------------------------------------------------- */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    ::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.06);
      border-radius: 999px;
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(108,240,255,0.35), rgba(108,240,255,0.18));
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
    }

    /* -- Credits ------------------------------------------------------------- */
    .credits {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-top: 8px;
    }

    /* -- End of 300+ lines CSS ---------------------------------------------- */
  </style>
</head>
<body>
  <!-- Background layer for gradient ambience -->
  <div class="bg-layer"></div>

  <!-- HUD: score, health, currency -->
  <div class="hud">
    <div class="hud-item">
      <div class="hud-label">Score</div>
      <div class="hud-value" id="hudScore">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Health</div>
      <div class="hud-value" id="hudHealth">100</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Credits</div>
      <div class="hud-value" id="hudCredits">0</div>
    </div>
  </div>

  <!-- Main canvas for gameplay -->
  <canvas id="gameCanvas"></canvas>

  <!-- Screens -->
  <div class="screen" id="screenLoading">
    <div class="screen-content panel">
      <div class="panel-title loading-logo">Bullet-Hell Clicker</div>
      <div class="divider"></div>
      <div class="loading-bar">
        <div class="loading-fill" id="loadingFill"></div>
      </div>
      <div class="credits">Loading assets and initializing systemsâ€¦</div>
    </div>
  </div>

  <div class="screen screen-hidden" id="screenMenu">
    <div class="screen-content panel">
      <div class="panel-title">Main Menu</div>
      <div class="menu-grid">
        <div class="menu-hero">
          <div class="badge">Glassmorphism UI</div>
          <div class="divider"></div>
          <p class="label">Welcome, Matteo. This is your deploy-ready, juice-heavy bullet-hell clicker. No librariesâ€”just raw JS and CSS.</p>
          <div class="meter">
            <div class="meter-dot"></div><div class="meter-dot"></div><div class="meter-dot"></div><div class="meter-dot"></div><div class="meter-dot"></div>
            <div class="meter-dot"></div><div class="meter-dot"></div><div class="meter-dot"></div><div class="meter-dot"></div><div class="meter-dot"></div>
          </div>
        </div>
        <div class="menu-actions">
          <button class="btn btn-primary" id="btnPlay">Play</button>
          <button class="btn" id="btnLevels">Level Selector</button>
          <button class="btn" id="btnShop">Shop</button>
          <button class="btn btn-danger" id="btnQuit">Quit</button>
        </div>
      </div>
      <div class="credits">Built for escalation, juice, and badge-worthy artifacts.</div>
    </div>
  </div>

  <div class="screen screen-hidden" id="screenLevels">
    <div class="screen-content panel">
      <div class="panel-title">Level Selector</div>
      <div class="level-grid" id="levelGrid"></div>
      <div class="divider"></div>
      <button class="btn" id="btnBackFromLevels">Back</button>
    </div>
  </div>

  <div class="screen screen-hidden" id="screenShop">
    <div class="screen-content panel">
      <div class="panel-title">Shop</div>
      <div class="shop-grid" id="shopGrid"></div>
      <div class="divider"></div>
      <button class="btn" id="btnBackFromShop">Back</button>
    </div>
  </div>

  <div class="screen screen-hidden" id="screenGameOver">
    <div class="screen-content gameover-panel">
      <div class="gameover-title">Game Over</div>
      <div class="divider"></div>
      <p class="label">You were overwhelmed by the swarm. Your score and credits are tallied below.</p>
      <div class="divider"></div>
      <div class="menu-actions">
        <button class="btn btn-primary" id="btnRetry">Retry</button>
        <button class="btn" id="btnReturnMenu">Return to Menu</button>
      </div>
    </div>
  </div>

  <!-- Floating action button for quick mute/unmute -->
  <div class="fab" id="fabAudio" title="Toggle Audio">
    ðŸ”Š
  </div>

  <!-- Toast notification container -->
  <div class="toast screen-hidden" id="toast"></div>

  <script>
    "use strict";

    /* =========================================================================
       GLOBALS & UTILITY HELPERS
       ========================================================================= */

    /** @type {HTMLCanvasElement} - Main game canvas element */
    const canvas = document.getElementById("gameCanvas");
    /** @type {CanvasRenderingContext2D} - 2D rendering context for the canvas */
    const ctx = canvas.getContext("2d");

    /** @type {HTMLElement} - HUD score element */
    const hudScoreEl = document.getElementById("hudScore");
    /** @type {HTMLElement} - HUD health element */
    const hudHealthEl = document.getElementById("hudHealth");
    /** @type {HTMLElement} - HUD credits element */
    const hudCreditsEl = document.getElementById("hudCredits");

    /** @type {HTMLElement} - Loading screen container */
    const screenLoading = document.getElementById("screenLoading");
    /** @type {HTMLElement} - Main menu screen container */
    const screenMenu = document.getElementById("screenMenu");
    /** @type {HTMLElement} - Level selector screen container */
    const screenLevels = document.getElementById("screenLevels");
    /** @type {HTMLElement} - Shop screen container */
    const screenShop = document.getElementById("screenShop");
    /** @type {HTMLElement} - Game over screen container */
    const screenGameOver = document.getElementById("screenGameOver");

    /** @type {HTMLElement} - Loading bar fill element */
    const loadingFill = document.getElementById("loadingFill");

    /** @type {HTMLElement} - Level grid container */
    const levelGrid = document.getElementById("levelGrid");
    /** @type {HTMLElement} - Shop grid container */
    const shopGrid = document.getElementById("shopGrid");

    /** @type {HTMLElement} - Toast notification element */
    const toastEl = document.getElementById("toast");

    /** @type {HTMLElement} - Audio FAB element */
    const fabAudio = document.getElementById("fabAudio");

    /** @type {number} - Canvas width */
    let W = 0;
    /** @type {number} - Canvas height */
    let H = 0;

    /** @type {boolean} - Global audio enabled flag */
    let AUDIO_ENABLED = true;

    /** @type {number} - Global time accumulator for animations */
    let globalTime = 0;

    /** @type {number} - RequestAnimationFrame handle */
    let rafId = 0;

    /** @type {number} - Current level index (0..9) */
    let currentLevelIndex = 0;

    /** @type {number} - Player score */
    let score = 0;
    /** @type {number} - Player health */
    let health = 100;
    /** @type {number} - Player credits (currency) */
    let credits = 0;

    /** @type {boolean} - Mouse pressed flag */
    let mouseDown = false;
    /** @type {{x:number,y:number}} - Mouse position */
    const mouse = { x: 0, y: 0 };

    /** @type {boolean} - Debug draw toggles */
    const DEBUG = {
      hitboxes: false,
      particles: false,
      enemies: false,
    };

    /**
     * Updates canvas size to match window dimensions.
     * Ensures crisp rendering and correct coordinate system.
     */
    function resizeCanvas() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    /**
     * Shows a toast notification with a message for a short duration.
     * @param {string} msg - Message to display in the toast.
     * @param {number} [duration=1500] - Duration in milliseconds.
     */
    function showToast(msg, duration = 1500) {
      toastEl.textContent = msg;
      toastEl.classList.remove("screen-hidden");
      setTimeout(() => {
        toastEl.classList.add("screen-hidden");
      }, duration);
    }

    /**
     * Adds or removes a CSS class from the body to trigger screen shake.
     * @param {boolean} hard - Whether to use hard shake or soft shake.
     */
    function triggerShake(hard = false) {
      const cls = hard ? "shake-hard" : "shake-soft";
      document.body.classList.add(cls);
      setTimeout(() => document.body.classList.remove(cls), hard ? 600 : 1200);
    }

    /* =========================================================================
       STATE MACHINE
       ========================================================================= */

    /**
     * Enum-like object for game states.
     * LOADING: initial asset setup
     * MENU: main menu
     * LEVELS: level selector
     * SHOP: shop system
     * GAME: active gameplay loop
     * GAMEOVER: game over screen
     */
    const STATES = {
      LOADING: "LOADING",
      MENU: "MENU",
      LEVELS: "LEVELS",
      SHOP: "SHOP",
      GAME: "GAME",
      GAMEOVER: "GAMEOVER",
    };

    /** @type {string} - Current game state */
    let currentState = STATES.LOADING;

    /**
     * Sets the current game state and updates screen visibility.
     * @param {string} state - Target state from STATES.
     */
    function setState(state) {
      currentState = state;
      // Hide all screens
      screenLoading.classList.add("screen-hidden");
      screenMenu.classList.add("screen-hidden");
      screenLevels.classList.add("screen-hidden");
      screenShop.classList.add("screen-hidden");
      screenGameOver.classList.add("screen-hidden");

      // Show relevant screen
      switch (state) {
        case STATES.LOADING:
          screenLoading.classList.remove("screen-hidden");
          break;
        case STATES.MENU:
          screenMenu.classList.remove("screen-hidden");
          break;
        case STATES.LEVELS:
          screenLevels.classList.remove("screen-hidden");
          break;
        case STATES.SHOP:
          screenShop.classList.remove("screen-hidden");
          break;
        case STATES.GAME:
          // Gameplay uses canvas; no overlay screen
          break;
        case STATES.GAMEOVER:
          screenGameOver.classList.remove("screen-hidden");
          break;
      }
    }

    /* =========================================================================
       INPUT HANDLERS
       ========================================================================= */

    // Mouse move updates position
    window.addEventListener("mousemove", (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    // Mouse down toggles clicker fire
    window.addEventListener("mousedown", () => {
      mouseDown = true;
      // Play click sound via audio manager
      AudioManager.playClick();
    });

    // Mouse up stops clicker fire
    window.addEventListener("mouseup", () => {
      mouseDown = false;
    });

    // Prevent context menu to keep right-click free (optional)
    window.addEventListener("contextmenu", (e) => e.preventDefault());

    /* =========================================================================
       WEB AUDIO API â€” PROCEDURAL AUDIO MANAGER
       ========================================================================= */

    /**
     * AudioManager handles procedural sound generation using Web Audio API.
     * - click: short blip for UI and firing
     * - explosion: noise burst with decay
     * - levelUp: synth fanfare with multiple oscillators
     */
    const AudioManager = (() => {
      /** @type {AudioContext|null} - Shared audio context */
      let ctx = null;

      /**
       * Initializes the audio context if not already created.
       * Called lazily on first sound play.
       */
      function ensureContext() {
        if (!ctx) {
          ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
      }

      /**
       * Plays a short click sound using a sine oscillator.
       * Frequency slightly randomized for variation.
       */
      function playClick() {
        if (!AUDIO_ENABLED) return;
        ensureContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = 220 + Math.random() * 80;
        gain.gain.value = 0.15;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        // Quick decay
        gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.08);
        osc.stop(ctx.currentTime + 0.1);
      }

      /**
       * Plays an explosion sound using noise + lowpass filter + decay envelope.
       * Adds a subtle pitch drop for extra juice.
       */
      function playExplosion() {
        if (!AUDIO_ENABLED) return;
        ensureContext();

        // Noise buffer
        const bufferSize = 2 * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuffer;

        const filter = ctx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 1200 + Math.random() * 800;

        const gain = ctx.createGain();
        gain.gain.value = 0.25;

        noise.connect(filter).connect(gain).connect(ctx.destination);
        noise.start();

        // Decay envelope
        gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.6);
        noise.stop(ctx.currentTime + 0.65);

        // Pitch drop oscillator for body
        const osc = ctx.createOscillator();
        const oscGain = ctx.createGain();
        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(220, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.5);
        oscGain.gain.value = 0.12;
        osc.connect(oscGain).connect(ctx.destination);
        osc.start();
        oscGain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5);
        osc.stop(ctx.currentTime + 0.52);
      }

      /**
       * Plays a level-up fanfare using layered oscillators and a simple arpeggio.
       * Adds stereo panning and gentle reverb-like delay.
       */
      function playLevelUp() {
        if (!AUDIO_ENABLED) return;
        ensureContext();

        const notes = [261.63, 329.63, 392.00, 523.25]; // C major arpeggio
        const baseTime = ctx.currentTime;

        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          const pan = ctx.createStereoPanner();
          osc.type = i % 2 === 0 ? "triangle" : "square";
          osc.frequency.value = freq;
          gain.gain.value = 0.12;
          pan.pan.value = (i % 2 === 0) ? -0.4 : 0.4;
          osc.connect(gain).connect(pan).connect(ctx.destination);
          const t = baseTime + i * 0.12;
          osc.start(t);
          gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.4);
          osc.stop(t + 0.42);
        });

        // Sub-osc for warmth
        const sub = ctx.createOscillator();
        const subGain = ctx.createGain();
        sub.type = "sine";
        sub.frequency.value = 130.81; // C3
        subGain.gain.value = 0.08;
        sub.connect(subGain).connect(ctx.destination);
        sub.start(baseTime);
        subGain.gain.exponentialRampToValueAtTime(0.0001, baseTime + 0.6);
        sub.stop(baseTime + 0.62);
      }

      /**
       * Toggles audio enabled flag and updates FAB icon.
       */
      function toggleAudio() {
        AUDIO_ENABLED = !AUDIO_ENABLED;
        fabAudio.textContent = AUDIO_ENABLED ? "ðŸ”Š" : "ðŸ”‡";
        showToast(AUDIO_ENABLED ? "Audio enabled" : "Audio muted");
      }

      return {
        playClick,
        playExplosion,
        playLevelUp,
        toggleAudio,
      };
    })();

    fabAudio.addEventListener("click", AudioManager.toggleAudio);

    /* =========================================================================
       PARTICLE SYSTEM â€” HEAVY-DUTY JUICE ENGINE
       ========================================================================= */

    /**
     * Represents a single particle with physics and color cycling.
     */
    class Particle {
      /**
       * @param {number} x - Initial x position
       * @param {number} y - Initial y position
       * @param {number} vx - Initial x velocity
       * @param {number} vy - Initial y velocity
       * @param {number} life - Lifetime in frames
       * @param {string} color - Base color string
       * @param {number} size - Radius in pixels
       */
      constructor(x, y, vx, vy, life, color, size) {
        /** @type {number} - X position */
        this.x = x;
        /** @type {number} - Y position */
        this.y = y;
        /** @type {number} - X velocity */
        this.vx = vx;
        /** @type {number} - Y velocity */
        this.vy = vy;
        /** @type {number} - Remaining life in frames */
        this.life = life;
        /** @type {string} - Base color */
        this.color = color;
        /** @type {number} - Particle size (radius) */
        this.size = size;
        /** @type {number} - Friction factor applied per frame */
        this.friction = 0.98;
        /** @type {number} - Gravity applied per frame */
        this.gravity = 0.02;
        /** @type {number} - Hue shift for color cycling */
        this.hue = Math.random() * 360;
      }

      /**
       * Updates particle physics and life.
       */
      update() {
        this.vx *= this.friction;
        this.vy = this.vy * this.friction + this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.hue += 1.2; // color cycling
      }

      /**
       * Renders the particle to the canvas.
       * Uses additive blending for extra juice.
       * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
       */
      draw(ctx) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, 0.6)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      /**
       * Checks if the particle is still alive.
       * @returns {boolean} True if life > 0
       */
      isAlive() {
        return this.life > 0;
      }
    }

    /**
     * Manages a pool of particles with efficient updates and rendering.
     * Capable of handling 500+ particles simultaneously.
     */
    class ParticleSystem {
      constructor() {
        /** @type {Particle[]} - Active particles array */
        this.particles = [];
        /** @type {number} - Maximum particles allowed */
        this.maxParticles = 1200; // generous cap
      }

      /**
       * Spawns a burst of particles at a given position.
       * @param {number} x - X position
       * @param {number} y - Y position
       * @param {number} count - Number of particles to spawn
       * @param {number} speed - Base speed for velocity
       * @param {number} size - Base size for particles
       */
      burst(x, y, count = 40, speed = 3.5, size = 2.2) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const s = speed * (0.6 + Math.random() * 0.8);
          const vx = Math.cos(angle) * s;
          const vy = Math.sin(angle) * s;
          const life = 40 + Math.random() * 40;
          const color = "#6cf0ff";
          const p = new Particle(x, y, vx, vy, life, color, size + Math.random() * 1.5);
          if (this.particles.length < this.maxParticles) {
            this.particles.push(p);
          } else {
            // Replace oldest when at cap
            this.particles[(Math.random() * this.particles.length) | 0] = p;
          }
        }
      }

      /**
       * Emits a directional stream of particles (used for bullets or trails).
       * @param {number} x - X position
       * @param {number} y - Y position
       * @param {number} dirX - Direction X
       * @param {number} dirY - Direction Y
       * @param {number} count - Number of particles
       */
      stream(x, y, dirX, dirY, count = 12) {
        for (let i = 0; i < count; i++) {
          const jitterX = (Math.random() - 0.5) * 0.6;
          const jitterY = (Math.random() - 0.5) * 0.6;
          const vx = dirX * (2.2 + Math.random() * 1.2) + jitterX;
          const vy = dirY * (2.2 + Math.random() * 1.2) + jitterY;
          const life = 24 + Math.random() * 16;
          const color = "#ff6cf0";
          const p = new Particle(x, y, vx, vy, life, color, 1.8 + Math.random() * 1.2);
          if (this.particles.length < this.maxParticles) {
            this.particles.push(p);
          } else {
            this.particles[(Math.random() * this.particles.length) | 0] = p;
          }
        }
      }

      /**
       * Updates all particles and prunes dead ones.
       */
      update() {
        const arr = this.particles;
        for (let i = arr.length - 1; i >= 0; i--) {
          const p = arr[i];
          p.update();
          if (!p.isAlive()) {
            arr.splice(i, 1);
          }
        }
      }

      /**
       * Draws all particles to the canvas.
       * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
       */
      draw(ctx) {
        const arr = this.particles;
        for (let i = 0; i < arr.length; i++) {
          arr[i].draw(ctx);
        }
      }
    }

    /** @type {ParticleSystem} - Global particle system instance */
    const particles = new ParticleSystem();

    /* =========================================================================
       PLAYER, BULLETS, ENEMIES
       ========================================================================= */

    /**
     * Represents the player entity.
     * In this clicker, the player is a cursor-centric shooter with auto-fire on click.
     */
    class Player {
      constructor() {
        /** @type {number} - Player X position */
        this.x = W / 2;
        /** @type {number} - Player Y position */
        this.y = H / 2;
        /** @type {number} - Player radius */
        this.r = 12;
        /** @type {number} - Fire cooldown in frames */
        this.cooldown = 0;
        /** @type {number} - Fire rate (lower is faster) */
        this.fireRate = 8;
        /** @type {number} - Bullet speed */
        this.bulletSpeed = 8;
        /** @type {number} - Bullet damage */
        this.damage = 10;
      }

      /**
       * Updates player position to follow mouse and handles firing.
       */
      update() {
        this.x = mouse.x;
        this.y = mouse.y;

        if (this.cooldown > 0) this.cooldown--;

        if (mouseDown && this.cooldown <= 0) {
          this.fire();
          this.cooldown = this.fireRate;
        }
      }

      /**
       * Fires a bullet towards the nearest enemy or straight up if none.
       * Spawns particle stream for muzzle flash.
       */
      fire() {
        const target = EnemyManager.getNearest(this.x, this.y);
        let dirX = 0, dirY = -1;
        if (target) {
          const dx = target.x - this.x;
          const dy = target.y - this.y;
          const len = Math.hypot(dx, dy) || 1;
          dirX = dx / len;
          dirY = dy / len;
        }
        const b = new Bullet(this.x, this.y, dirX * this.bulletSpeed, dirY * this.bulletSpeed, this.damage);
        bullets.push(b);
        particles.stream(this.x, this.y, dirX, dirY, 16);
      }

      /**
       * Draws the player as a glowing circle.
       * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
       */
      draw(ctx) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = "rgba(108,240,255,0.8)";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        if (DEBUG.hitboxes) {
          ctx.strokeStyle = "#0ff";
          ctx.strokeRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
        }
      }
    }

    /**
     * Represents a bullet fired by the player.
     */
    class Bullet {
      /**
       * @param {number} x - Initial x position
       * @param {number} y - Initial y position
       * @param {number} vx - Velocity x
       * @param {number} vy - Velocity y
       * @param {number} damage - Damage dealt to enemies
       */
      constructor(x, y, vx, vy, damage) {
        /** @type {number} - X position */
        this.x = x;
        /** @type {number} - Y position */
        this.y = y;
        /** @type {number} - X velocity */
        this.vx = vx;
        /** @type {number} - Y velocity */
        this.vy = vy;
        /** @type {number} - Bullet radius */
        this.r = 4;
        /** @type {number} - Damage value */
        this.damage = damage;
        /** @type {number} - Lifetime frames */
        this.life = 120;
      }

      /**
       * Updates bullet position and lifetime.
       */
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
      }

      /**
       * Draws the bullet as a glowing dot.
       * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
       */
      draw(ctx) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = "rgba(255,108,240,0.8)";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      /**
       * Checks if bullet is still alive and within bounds.
       * @returns {boolean} True if alive
       */
      isAlive() {
        return this.life > 0 && this.x >= -20 && this.x <= W + 20 && this.y >= -20 && this.y <= H + 20;
      }
    }

    /** @type {Bullet[]} - Active bullets array */
    const bullets = [];

    /**
     * Enemy base class with shared properties.
     */
    class Enemy {
      /**
       * @param {number} x - Initial x position
       * @param {number} y - Initial y position
       * @param {number} hp - Hit points
       * @param {number} type - Enemy type index
       */
      constructor(x, y, hp, type) {
        /** @type {number} - X position */
        this.x = x;
        /** @type {number} - Y position */
        this.y = y;
        /** @type {number} - Velocity X */
        this.vx = 0;
        /** @type {number} - Velocity Y */
        this.vy = 0;
        /** @type {number} - Radius */
        this.r = 14;
        /** @type {number} - Hit points */
        this.hp = hp;
        /** @type {number} - Enemy type */
        this.type = type;
        /** @type {number} - Internal timer for movement patterns */
        this.t = Math.random() * 1000;
        /** @type {number} - Teleport cooldown (for teleporters) */
        this.teleportCooldown = 120 + (Math.random() * 60)|0;
      }

      /**
       * Updates enemy movement based on type.
       * Types:
       * 0 - Sine wave horizontal
       * 1 - Circling around a point
       * 2 - Tracking player
       * 3 - Teleporting randomly
       * 4 - Wandering with noise
       */
      update() {
        this.t += 0.02;

        switch (this.type) {
          case 0: // Sine wave horizontal
            this.vx = Math.sin(this.t * 2.0) * 2.0;
            this.vy = 1.2 + Math.sin(this.t) * 0.6;
            break;
          case 1: // Circling
            this.vx = Math.cos(this.t * 1.5) * 2.2;
            this.vy = Math.sin(this.t * 1.5) * 2.2;
            break;
          case 2: // Tracking player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const len = Math.hypot(dx, dy) || 1;
            this.vx = (dx / len) * 1.8;
            this.vy = (dy / len) * 1.8;
            break;
          case 3: // Teleporting
            this.vx *= 0.95;
            this.vy *= 0.95;
            this.teleportCooldown--;
            if (this.teleportCooldown <= 0) {
              this.x = Math.random() * W;
              this.y = Math.random() * H * 0.5;
              this.teleportCooldown = 120 + (Math.random() * 60)|0;
              particles.burst(this.x, this.y, 30, 2.5, 2.0);
            }
            break;
          case 4: // Wandering with noise
            this.vx += (Math.random() - 0.5) * 0.6;
            this.vy += (Math.random() - 0.5) * 0.6;
            this.vx = Math.max(Math.min(this.vx, 2.2), -2.2);
            this.vy = Math.max(Math.min(this.vy, 2.2), -2.2);
            break;
        }

        this.x += this.vx;
        this.y += this.vy;

        // Keep within bounds
        if (this.x < 0) this.x = 0;
        if (this.x > W) this.x = W;
        if (this.y < 0) this.y = 0;
        if (this.y > H) this.y = H;

        // Collision with player (simple overlap)
        const dxp = player.x - this.x;
        const dyp = player.y - this.y;
        const dist = Math.hypot(dxp, dyp);
        if (dist < this.r + player.r) {
          // Damage player and knock enemy slightly
          health -= 1;
          this.vx += (Math.random() - 0.5) * 2.0;
          this.vy += (Math.random() - 0.5) * 2.0;
          triggerShake(true);
          particles.burst(player.x, player.y, 20, 2.0, 2.0);
          if (health <= 0) {
            Game.endGame();
          }
        }
      }

      /**
       * Draws the enemy as a glowing circle with HP ring.
       * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
       */
      draw(ctx) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const base = ["#6cf0ff", "#ff6cf0", "#f0ff6c", "#ff4d6d", "#4dff88"][this.type % 5];
        ctx.fillStyle = base + "cc";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();

        // HP ring
        ctx.strokeStyle = base;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 4, 0, (this.hp % 20) / 20 * Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        if (DEBUG.hitboxes) {
          ctx.strokeStyle = "#f00";
          ctx.strokeRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
        }
      }

      /**
       * Applies damage to the enemy and returns whether it died.
       * @param {number} dmg - Damage amount
       * @returns {boolean} True if enemy died
       */
      hit(dmg) {
        this.hp -= dmg;
        particles.burst(this.x, this.y, 12, 2.0, 1.6);
        if (this.hp <= 0) {
          AudioManager.playExplosion();
          particles.burst(this.x, this.y, 40, 3.0, 2.4);
          score += 10;
          credits += 1;
          return true;
        }
        return false;
      }
    }

    /**
     * Manages enemies: spawning, updating, drawing, and collision with bullets.
     */
    const EnemyManager = (() => {
      /** @type {Enemy[]} - Active enemies array */
      const enemies = [];

      /**
       * Spawns a wave of enemies with mixed types.
       * @param {number} count - Number of enemies to spawn
       */
      function spawnWave(count = 12) {
        for (let i = 0; i < count; i++) {
          const x = Math.random() * W;
          const y = Math.random() * H * 0.5;
          const hp = 20 + (Math.random() * 20)|0;
          const type = (Math.random() * 5)|0;
          enemies.push(new Enemy(x, y, hp, type));
        }
      }

      /**
       * Updates all enemies and handles bullet collisions.
       */
      function update() {
        // Spawn logic: keep at least N enemies
        if (enemies.length < 18) {
          spawnWave(6);
        }

        // Update enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          e.update();
        }

        // Bullet collisions
        for (let b = bullets.length - 1; b >= 0; b--) {
          const bullet = bullets[b];
          for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dx = e.x - bullet.x;
            const dy = e.y - bullet.y;
            const dist = Math.hypot(dx, dy);
            if (dist < e.r + bullet.r) {
              const died = e.hit(bullet.damage);
              bullets.splice(b, 1);
              if (died) enemies.splice(i, 1);
              break;
            }
          }
        }

        // Prune bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          if (!bullets[i].isAlive()) bullets.splice(i, 1);
        }
      }

      /**
       * Draws all enemies.
       * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
       */
      function draw(ctx) {
        for (let i = 0; i < enemies.length; i++) {
          enemies[i].draw(ctx);
        }
      }

      /**
       * Clears all enemies (used on game end or level change).
       */
      function clear() {
        enemies.length = 0;
      }

      /**
       * Returns the nearest enemy to a given position.
       * @param {number} x - X position
       * @param {number} y - Y position
       * @returns {Enemy|null} Nearest enemy or null
       */
      function getNearest(x, y) {
        let nearest = null;
        let bestDist = Infinity;
        for (let i = 0; i < enemies.length; i++) {
          const e = enemies[i];
          const d = Math.hypot(e.x - x, e.y - y);
          if (d < bestDist) {
            bestDist = d;
            nearest = e;
          }
        }
        return nearest;
      }

      return {
        spawnWave,
        update,
        draw,
        clear,
        getNearest,
      };
    })();

    /** @type {Player} - Player instance */
    const player = new Player();

    /* =========================================================================
       GAME LOOP & RENDERING
       ========================================================================= */

    /**
     * Clears the canvas with a subtle gradient fade.
     */
    function clearCanvas() {
      ctx.clearRect(0, 0, W, H);
      // Optional: faint vignette
      const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)/1.2);
      grad.addColorStop(0, "rgba(10,14,24,0.0)");
      grad.addColorStop(1, "rgba(10,14,24,0.25)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    }

    /**
     * Updates HUD elements to reflect current game stats.
     */
    function updateHUD() {
      hudScoreEl.textContent = score;
      hudHealthEl.textContent = Math.max(0, health);
      hudCreditsEl.textContent = credits;
    }

    /**
     * Main game update function called each frame.
     * Handles player, enemies, bullets, particles, and HUD.
     */
    function update() {
      globalTime += 1/60;

      player.update();
      EnemyManager.update();

      particles.update();

      updateHUD();
    }

    /**
     * Main game draw function called each frame.
     * Renders background, particles, enemies, bullets, and player.
     */
    function draw() {
      clearCanvas();

      // Background decorative lines
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = "#6cf0ff";
      ctx.lineWidth = 1;
      for (let i = 0; i < 12; i++) {
        ctx.beginPath();
        ctx.moveTo(0, (i + 1) * (H / 12));
        ctx.lineTo(W, (i + 1) * (H / 12));
        ctx.stroke();
      }
      ctx.restore();

      // Draw particles behind entities
      particles.draw(ctx);

      // Draw bullets
      for (let i = 0; i < bullets.length; i++) {
        bullets[i].draw(ctx);
      }

      // Draw enemies
      EnemyManager.draw(ctx);

      // Draw player
      player.draw(ctx);
    }

    /**
     * Game loop using requestAnimationFrame.
     */
    function loop() {
      if (currentState === STATES.GAME) {
        update();
        draw();
      }
      rafId = requestAnimationFrame(loop);
    }

    /* =========================================================================
       GAME CONTROL â€” START/END/RESET
       ========================================================================= */

    const Game = (() => {
      /**
       * Starts a new game session for the current level.
       * Resets stats and spawns initial enemies.
       */
      function start() {
        score = 0;
        health = 100;
        credits = 0;
        EnemyManager.clear();
        bullets.length = 0;
        particles.burst(W/2, H/2, 80, 3.5, 2.4);
        AudioManager.playLevelUp();
        setState(STATES.GAME);
      }

      /**
       * Ends the current game session and shows the Game Over screen.
       */
      function endGame() {
        setState(STATES.GAMEOVER);
        triggerShake(true);
      }

      /**
       * Returns to main menu and clears gameplay entities.
       */
      function returnToMenu() {
        setState(STATES.MENU);
        EnemyManager.clear();
        bullets.length = 0;
      }

      return {
        start,
        endGame,
        returnToMenu,
      };
    })();

    /* =========================================================================
       UI WIRING â€” BUTTONS & LEVEL/SHOP POPULATION
       ========================================================================= */

    // Menu buttons
    document.getElementById("btnPlay").addEventListener("click", () => {
      Game.start();
    });

    document.getElementById("btnLevels").addEventListener("click", () => {
      setState(STATES.LEVELS);
    });

    document.getElementById("btnShop").addEventListener("click", () => {
      setState(STATES.SHOP);
    });

    document.getElementById("btnQuit").addEventListener("click", () => {
      showToast("Quit not implementedâ€”this is a browser game.");
    });

    // Game Over buttons
    document.getElementById("btnRetry").addEventListener("click", () => {
      Game.start();
    });

    document.getElementById("btnReturnMenu").addEventListener("click", () => {
      Game.returnToMenu();
    });

    // Back buttons
    document.getElementById("btnBackFromLevels").addEventListener("click", () => {
      setState(STATES.MENU);
    });

    document.getElementById("btnBackFromShop").addEventListener("click", () => {
      setState(STATES.MENU);
    });

    /**
     * Populates the level selector with 10 dummy levels.
     * Each level card sets currentLevelIndex and starts the game.
     */
    function populateLevels() {
      levelGrid.innerHTML = "";
      for (let i = 0; i < 10; i++) {
        const card = document.createElement("div");
        card.className = "level-card";
        const title = document.createElement("div");
        title.className = "level-title";
        title.textContent = `Level ${i + 1}`;
        const desc = document.createElement("div");
        desc.className = "level-desc";
        desc.textContent = "Dummy levelâ€”tuned for testing enemy patterns and juice.";
        card.appendChild(title);
        card.appendChild(desc);
        card.addEventListener("click", () => {
          currentLevelIndex = i;
          showToast(`Starting Level ${i + 1}`);
          Game.start();
        });
        levelGrid.appendChild(card);
      }
    }

    /**
     * Populates the shop with upgrade items.
     * Each item modifies player stats and costs credits.
     */
    function populateShop() {
      shopGrid.innerHTML = "";
      const items = [
        { name: "Fire Rate+", desc: "Shoot faster. Decrease cooldown.", price: 10, apply: () => player.fireRate = Math.max(2, player.fireRate - 1) },
        { name: "Damage+", desc: "Increase bullet damage.", price: 12, apply: () => player.damage += 2 },
        { name: "Speed+", desc: "Increase bullet speed.", price: 8, apply: () => player.bulletSpeed += 0.8 },
        { name: "Health+", desc: "Boost max health by 10.", price: 15, apply: () => health += 10 },
        { name: "Particle Max+", desc: "Increase particle cap for more juice.", price: 20, apply: () => particles.maxParticles += 100 },
        { name: "Lucky+", desc: "Increase credit gain chance.", price: 18, apply: () => { /* placeholder for future luck system */ } },
        { name: "Tracker+", desc: "Improve targeting precision.", price: 14, apply: () => { /* placeholder for aim assist */ } },
        { name: "Shield+", desc: "Reduce collision damage.", price: 22, apply: () => { /* placeholder for damage reduction */ } },
        { name: "Fanfare+", desc: "Upgraded level-up audio.", price: 16, apply: () => AudioManager.playLevelUp() },
      ];

      items.forEach((item) => {
        const el = document.createElement("div");
        el.className = "shop-item";
        const title = document.createElement("div");
        title.className = "shop-title";
        title.textContent = item.name;
        const desc = document.createElement("div");
        desc.className = "shop-desc";
        desc.textContent = item.desc;
        const price = document.createElement("div");
        price.className = "shop-price";
        price.textContent = `${item.price} credits`;
        const btn = document.createElement("button");
        btn.className = "btn btn-ok";
        btn.textContent = "Buy";
        btn.addEventListener("click", () => {
          if (credits >= item.price) {
            credits -= item.price;
            item.apply();
            showToast(`${item.name} purchased`);
            AudioManager.playClick();
          } else {
            showToast("Not enough credits");
          }
        });
        el.appendChild(title);
        el.appendChild(desc);
        el.appendChild(price);
        el.appendChild(btn);
        shopGrid.appendChild(el);
      });
    }

    /* =========================================================================
       LOADING SEQUENCE
       ========================================================================= */

    /**
     * Simulates loading with a timed progress bar, then transitions to menu.
     */
    function simulateLoading() {
      let progress = 0;
      const interval = setInterval(() => {
        progress += Math.random() * 0.12;
        loadingFill.style.width = Math.min(100, progress * 100) + "%";
        if (progress >= 1) {
          clearInterval(interval);
          setTimeout(() => {
            setState(STATES.MENU);
          }, 400);
        }
      }, 120);
    }

    /* =========================================================================
       INITIALIZATION
       ========================================================================= */

    /**
     * Initializes UI, levels, shop, and starts the main loop.
     */
    function init() {
      setState(STATES.LOADING);
      populateLevels();
      populateShop();
      simulateLoading();
      loop();
    }

    init();

    /* =========================================================================
       EXTENDED COMMENTS & FUTURE HOOKS
       =========================================================================
       - Enemy bullets and patterns can be added by extending EnemyManager with
         projectile arrays and pattern schedulers.
       - Boss logic: create a Boss class with phases, telegraphs, and bullet
         patterns (spirals, rings, aimed shots).
       - Difficulty scaling: tie currentLevelIndex to spawn rates, enemy HP,
         and movement speed multipliers.
       - Save system: localStorage for upgrades and high scores.
       - Achievements: track milestones and show badge toasts.
       - Audio: add delay/reverb nodes for richer soundscapes.
       - Mobile: add touch controls and performance tuning.
       - Performance: batch draw calls, offscreen canvas for particles.
       - Accessibility: colorblind-friendly palettes and reduced motion toggle.
       ========================================================================= */
  </script>
</body>
</html>
```
