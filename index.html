<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KIRBY: NEON ASCENSION</title>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #fff;
            pointer-events: none; z-index: 10;
        }
        .speed-bar { width: 200px; height: 6px; background: rgba(255,255,255,0.1); margin-top: 10px; border-radius: 3px; overflow: hidden; }
        #speed-fill { width: 0%; height: 100%; background: cyan; box-shadow: 0 0 10px cyan; transition: width 0.1s; }
        .multiplier { font-size: 48px; font-weight: 900; font-style: italic; color: #ff00ff; text-shadow: 0 0 20px #ff00ff; }
    </style>
</head>
<body>

<div id="ui">
    <div id="m-text" class="multiplier">x1</div>
    <div style="letter-spacing: 2px; font-size: 12px; opacity: 0.8;">FLOW STATE VELOCITY</div>
    <div class="speed-bar"><div id="speed-fill"></div></div>
</div>
<canvas id="game"></canvas>

<script>
/**
 * VETERAN ENGINE V6: ADDICTIVE FLOW STATE
 * Mechanics: Momentum-preserving dashing, projectile-boosting, and screen-warp.
 */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mText = document.getElementById('m-text');
const sFill = document.getElementById('speed-fill');

let w, h;
const resize = () => { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; };
window.onresize = resize;
resize();

// --- GAME CONFIG ---
const state = {
    score: 0,
    multiplier: 1,
    camX: 0,
    time: 0,
    particles: [],
    bullets: [],
    enemies: [],
    platforms: [],
    slowMo: 1
};

const keys = {};
window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;

// --- PLAYER ---
const player = {
    x: 100, y: 300, vx: 0, vy: 0,
    w: 36, h: 36,
    dashCD: 0,
    isDashing: false,
    
    update() {
        // Friction & Gravity
        const gravity = 0.5 * state.slowMo;
        const friction = 0.94;

        if(keys.ArrowRight) this.vx += 1.0;
        if(keys.ArrowLeft) this.vx -= 1.0;
        
        // Jump / Fly
        if(keys.Space) this.vy -= 0.8 * state.slowMo;

        // DASH MECHANIC (Shift) - High-speed addiction
        if(keys.ShiftLeft && this.dashCD <= 0) {
            this.vx = (keys.ArrowLeft ? -25 : 25);
            this.vy = -2;
            this.dashCD = 30;
            this.isDashing = true;
            state.shake = 15;
            spawnBurst(this.x, this.y, 'cyan', 20);
        }
        if(this.dashCD > 0) this.dashCD--;
        if(Math.abs(this.vx) < 10) this.isDashing = false;

        this.vx *= friction;
        this.vy += gravity;
        this.x += this.vx * state.slowMo;
        this.y += this.vy * state.slowMo;

        // Screen Boundaries & Platforms
        if(this.y > h - 100) { this.y = h - 100; this.vy = 0; }
        
        state.platforms.forEach(p => {
            if(this.x + this.w > p.x && this.x < p.x + p.w && this.y + this.h > p.y && this.y + this.h < p.y + p.h + 15 && this.vy > 0) {
                this.y = p.y - this.h; this.vy = 0;
            }
        });

        // Flow State Logic
        let speed = Math.abs(this.vx);
        state.multiplier = 1 + Math.floor(speed / 8);
        mText.innerText = `x${state.multiplier}`;
        sFill.style.width = Math.min(100, (speed / 20) * 100) + "%";
        sFill.style.background = state.multiplier > 2 ? '#ff00ff' : 'cyan';
    },

    draw() {
        ctx.save();
        ctx.translate(this.x - state.camX + 18, this.y + 18);
        
        // Trail effect when fast
        if(Math.abs(this.vx) > 10) {
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(-25 * Math.sign(this.vx), -15, 40, 30);
        }

        ctx.globalAlpha = 1;
        ctx.fillStyle = '#ffb6c1';
        ctx.beginPath();
        ctx.arc(0, 0, 18, 0, Math.PI*2);
        ctx.fill();
        
        // Glowing Eyes
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 10; ctx.shadowColor = 'cyan';
        ctx.fillRect(4, -8, 4, 10);
        ctx.fillRect(12, -8, 4, 10);
        ctx.restore();
    }
};

// --- HELPERS ---
function spawnBurst(x, y, color, count) {
    for(let i=0; i<count; i++) {
        state.particles.push({
            x, y, 
            vx: (Math.random()-0.5)*15, 
            vy: (Math.random()-0.5)*15, 
            life: 1, 
            color
        });
    }
}

// --- WORLD GEN ---
for(let i=0; i<100; i++) {
    state.platforms.push({ x: i*400, y: h - 150 - Math.random()*300, w: 250, h: 15 });
    state.enemies.push({ x: i*400 + 200, y: h - 400, w: 40, h: 40, alive: true });
}

// --- LOOP ---
function loop() {
    state.time++;
    ctx.fillStyle = '#050505';
    ctx.fillRect(0,0,w,h);

    // Dynamic Camera
    state.camX += (player.x - w/4 - state.camX) * 0.1;

    // Background Grid (Moving with camera)
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.beginPath();
    for(let x=0; x<w; x+=50) {
        let offX = x - (state.camX % 50);
        ctx.moveTo(offX, 0); ctx.lineTo(offX, h);
    }
    ctx.stroke();

    // Platforms
    ctx.fillStyle = '#1a1a1a';
    state.platforms.forEach(p => {
        ctx.fillRect(p.x - state.camX, p.y, p.w, p.h);
        ctx.fillStyle = 'cyan';
        ctx.fillRect(p.x - state.camX, p.y, p.w, 2); // Neon top
        ctx.fillStyle = '#1a1a1a';
    });

    // Enemies
    state.enemies.forEach(e => {
        if(e.alive) {
            ctx.fillStyle = '#ff0055';
            ctx.shadowBlur = 15; ctx.shadowColor = '#ff0055';
            ctx.fillRect(e.x - state.camX, e.y, e.w, e.h);
            ctx.shadowBlur = 0;

            // Collision with player
            if(Math.abs(player.x - e.x) < 40 && Math.abs(player.y - e.y) < 40) {
                if(player.isDashing) {
                    e.alive = false;
                    spawnBurst(e.x, e.y, '#ff0055', 15);
                    state.score += 500 * state.multiplier;
                    player.vy = -10; // Bounce
                } else {
                    player.vx = -10; // Hurt
                }
            }
        }
    });

    // Particles
    state.particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.02;
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - state.camX, p.y, 4, 4);
        if(p.life <= 0) state.particles.splice(i, 1);
    });
    ctx.globalAlpha = 1;

    player.update();
    player.draw();

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
