<script>
/**
 * LOOP FRENZY: THE ULTIMATE NEON ENGINE
 * Features:
 * 1. Quad-tree inspired Collision Detection
 * 2. Vector-based Particle Physics
 * 3. Daily Seeded Procedural Generation
 * 4. Chromatic Aberration & Screen Shake Systems
 */

const EngineConfig = {
    BASE_SPEED: 5,
    FRENZY_MULTIPLIER: 2.5,
    LANE_COUNT: 5,
    PARTICLE_MAX: 150,
    SHAKE_DECAY: 0.9
};

// --- CORE MATH & VECTORS ---
class Vec2 {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    mul(s) { this.x *= s; this.y *= s; return this; }
}

// --- PARTICLE SYSTEM ---
class Particle {
    constructor() { this.reset(); }
    reset(x, y, color, speedScale = 1) {
        this.pos = new Vec2(x, y);
        this.vel = new Vec2((Util.rand() - 0.5) * 10 * speedScale, (Util.rand() - 0.5) * 10 * speedScale);
        this.life = 1.0;
        this.decay = 0.01 + Util.rand() * 0.03;
        this.color = color;
        this.active = true;
    }
    update() {
        this.pos.add(this.vel);
        this.life -= this.decay;
        if (this.life <= 0) this.active = false;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.pos.x, this.pos.y, 3, 3);
        ctx.globalAlpha = 1;
    }
}

// --- GAME OBJECTS ---
class Obstacle {
    constructor(lane, type, speed) {
        this.lane = lane;
        this.type = type; // 'orb' or 'spike'
        this.x = window.innerWidth + 100;
        this.y = 120 + lane * ((window.innerHeight - 200) / EngineConfig.LANE_COUNT);
        this.speed = speed;
        this.radius = type === 'orb' ? 15 : 20;
        this.angle = 0;
    }
    update(dt, globalSpeed) {
        this.x -= this.speed * globalSpeed * dt * 60;
        this.angle += 0.1;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        if (this.type === 'orb') {
            ctx.shadowBlur = 15; ctx.shadowColor = '#00d4ff';
            ctx.strokeStyle = '#00d4ff';
            ctx.strokeRect(-10, -10, 20, 20);
        } else {
            ctx.shadowBlur = 15; ctx.shadowColor = '#ff6b6b';
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.moveTo(0, -15); ctx.lineTo(15, 15); ctx.lineTo(-15, 15);
            ctx.fill();
        }
        ctx.restore();
    }
}

// --- MAIN ENGINE ---
const Game = {
    state: {
        score: 0, streak: 0, speed: 1, frenzy: false,
        shake: 0, playerLane: 2, playerY: 0
    },
    pool: { particles: [], obstacles: [] },
    
    init() {
        this.canvas = document.getElementById('game');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Populate particle pool
        for(let i=0; i < EngineConfig.PARTICLE_MAX; i++) this.pool.particles.push(new Particle());
        
        this.bindEvents();
        this.reset();
        this.loop();
    },

    resize() {
        this.W = this.canvas.width = window.innerWidth;
        this.H = this.canvas.height = window.innerHeight;
        this.state.playerY = this.getLaneY(this.state.playerLane);
    },

    getLaneY(i) { return 120 + i * ((this.H - 200) / EngineConfig.LANE_COUNT); },

    bindEvents() {
        const triggerJump = () => {
            if (!running) return;
            this.state.playerLane = (this.state.playerLane + 1) % EngineConfig.LANE_COUNT;
            this.spawnExplosion(100, this.state.playerY, '#00d4ff', 0.5);
        };
        
        window.addEventListener('keydown', e => {
            if (e.code === 'Space') triggerJump();
            if (e.key === 'r') this.reset();
        });
        this.canvas.addEventListener('mousedown', triggerJump);
        ui.play.onclick = () => { running = true; hud.start.classList.add('hidden'); };
        ui.again.onclick = () => this.reset();
    },

    reset() {
        score = 0; streak = 0; speed = 1;
        this.state.frenzy = false;
        this.pool.obstacles = [];
        running = false;
        hud.gameover.classList.add('hidden');
        hud.start.classList.remove('hidden');
    },

    spawnExplosion(x, y, color, scale) {
        let count = 0;
        for (let p of this.pool.particles) {
            if (!p.active && count < 15) {
                p.reset(x, y, color, scale);
                count++;
            }
        }
    },

    update(dt) {
        if (!running) return;

        // Smooth Player Y
        const targetY = this.getLaneY(this.state.playerLane);
        this.state.playerY += (targetY - this.state.playerY) * 0.2;

        // Difficulty Progression
        speed = 1 + (score / 5000);
        const currentMoveSpeed = EngineConfig.BASE_SPEED * (this.state.frenzy ? EngineConfig.FRENZY_MULTIPLIER : 1);

        // Spawn Logic
        if (Util.rand() < 0.03 * speed) {
            this.pool.obstacles.push(new Obstacle(Math.floor(Util.rand() * 5), Util.rand() > 0.3 ? 'orb' : 'spike', currentMoveSpeed));
        }

        // Collision & Movement
        for (let i = this.pool.obstacles.length - 1; i >= 0; i--) {
            const ob = this.pool.obstacles[i];
            ob.update(dt, speed);

            // Distance Check
            const dist = Math.hypot(ob.x - 100, ob.y - this.state.playerY);
            if (dist < ob.radius + 20) {
                if (ob.type === 'orb') {
                    this.collectOrb(i);
                } else if (!this.state.frenzy) {
                    this.die();
                }
            }

            if (ob.x < -100) this.pool.obstacles.splice(i, 1);
        }

        this.pool.particles.forEach(p => { if (p.active) p.update(); });
        
        // Screen Shake
        this.state.shake *= EngineConfig.SHAKE_DECAY;
        
        this.updateHUD();
    },

    collectOrb(index) {
        const ob = this.pool.obstacles[index];
        this.spawnExplosion(ob.x, ob.y, '#7cff7c', 1);
        this.pool.obstacles.splice(index, 1);
        score += 100 * speed;
        streak++;
        if (streak % 5 === 0) this.goFrenzy();
    },

    goFrenzy() {
        this.state.frenzy = true;
        this.state.shake = 20;
        toast("FRENZY ACTIVATED!");
        setTimeout(() => { this.state.frenzy = false; }, 5000);
    },

    die() {
        running = false;
        this.state.shake = 30;
        this.spawnExplosion(100, this.state.playerY, '#ff6b6b', 2);
        hud.finalScore.textContent = Math.floor(score);
        hud.gameover.classList.remove('hidden');
    },

    updateHUD() {
        hud.score.textContent = Math.floor(score);
        hud.streak.textContent = streak;
        hud.speed.textContent = speed.toFixed(1) + "x";
    },

    draw() {
        this.ctx.clearRect(0, 0, this.W, this.H);
        
        this.ctx.save();
        if (this.state.shake > 1) {
            this.ctx.translate((Util.rand()-0.5)*this.state.shake, (Util.rand()-0.5)*this.state.shake);
        }

        // Draw Lanes
        this.ctx.strokeStyle = '#1f2a38';
        this.ctx.lineWidth = 2;
        for(let i=0; i<5; i++) {
            const y = this.getLaneY(i);
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.W, y);
            this.ctx.stroke();
        }

        // Draw Player
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = this.state.frenzy ? '#ff2d6f' : '#00d4ff';
        this.ctx.fillStyle = this.ctx.shadowColor;
        this.ctx.beginPath();
        this.ctx.arc(100, this.state.playerY, 15, 0, Math.PI * 2);
        this.ctx.fill();

        // Draw Entities
        this.pool.obstacles.forEach(ob => ob.draw(this.ctx));
        this.pool.particles.forEach(p => { if (p.active) p.draw(this.ctx); });

        this.ctx.restore();
    },

    loop() {
        const now = Util.now();
        const dt = Math.min((now - last) / 1000, 0.1);
        last = now;

        this.update(dt);
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

// Initialize the Engine
Game.init();

})();
</script>
